// ====================================
// FUNCIÓN SOFT KNEE LIMITER
// ====================================
// Aplica limitación con transición suave (soft knee)
// xg: nivel de entrada en dB
// threshold: umbral de limitación en dB
// kneeWidth: ancho de la transición suave en dB
softkneeLimiter(xg, threshold, kneeWidth) {
    ret = 0;
    
    // Si la señal está muy por debajo del umbral (fuera de la rodilla)
    if ((2 * (xg - threshold)) < (kneeWidth * (-1))) {
        ret = xg;  // No hay reducción
    }
    // Si la señal está dentro de la zona de transición suave (rodilla)
    else if ((2 * abs(xg - threshold)) <= kneeWidth) {
        // Aplica reducción cuadrática para transición suave
        ret = xg - (pow((xg - threshold) - (kneeWidth / 2), 2) / (2 * kneeWidth));
    }
    // Si la señal está por encima del umbral (fuera de la rodilla)
    else if ((2 * (xg - threshold)) > kneeWidth) {
        ret = threshold;  // Limitación total al umbral
    }
    
    return ret;
}

// ====================================
// DECLARACIÓN DE PARÁMETROS
// ====================================
Param d_ATK(0, min=0.01, default=100, max=750);    // Tiempo de ataque en ms
Param b_CELLING(0, min=-60, default=-0.3, max=0);  // Techo máximo en dB
Param a_GAIN(0, min=0, default=0, max=24);         // Input gain (dB) - moderno
Param e_REL(0, min=1, default=200, max=1000);      // Tiempo de release en ms
Param g_DITHER(0, min=0, default=0, max=1);        // Cantidad de dither (0-1)
Param h_BYPASS(0, min=0, default=0, max=1);        // Bypass del efecto (0-1)
Param i_MAKEUP(0, min=-12, default=0, max=12);     // Makeup gain post-proceso (dB)
Param j_TRIM(-12, min=-12, default=0, max=12);     // Input trim gain (dB)
Param k_DELTA(0, min=0, default=0, max=1);         // Delta mode (0-1)
Param l_DETECT(0, min=0, default=0, max=1);        // Detection mode (0=Peak, 1=RMS)
Param m_AUTOREL(0, min=0, default=0, max=1);       // Auto-release enable (0-1)
Param n_LOOKAHEAD(0, min=0, default=0, max=5);     // Lookahead time (ms)

// ====================================
// VARIABLES DE ESTADO (HISTORIALES)
// ====================================
History smoothedGain(0);         // Suavizado del gain (antes threshold)
History smoothedCeiling(0);      // Suavizado del techo
History smoothedBypass(0);       // Suavizado del bypass
History smoothedMakeup(0);       // Suavizado del makeup gain
History envelopeFollower(0);     // Seguidor de envolvente para detección RMS
History gainReduction(0);        // Reducción de ganancia actual
History lookaheadHistory(0);     // Para suavizado del lookahead
History trimHistory(0);          // Para suavizado del trim
History deltaHistory(0);         // Para suavizado del modo delta
History detectHistory(0);        // Para suavizado del modo de detección
History autoReleaseHistory(0);   // Para suavizado del auto-release
History transientDetector(0);    // Detector de transientes para auto-release
History prevDetection(0);        // Detección anterior para calcular cambios
History rmsSum(0);               // Suma para RMS sliding window

// ====================================
// LÍNEAS DE DELAY PARA LOOKAHEAD
// ====================================
Delay delayLeft(samplerate);        // Delay canal izquierdo (con trim)
Delay delayRight(samplerate);       // Delay canal derecho (con trim)
Delay delayDetectLeft(samplerate);  // Delay detección izquierda
Delay delayDetectRight(samplerate); // Delay detección derecha
Delay leftInputDelay(samplerate);   // Delay canal izquierdo (sin trim para bypass)
Delay rightInputDelay(samplerate);  // Delay canal derecho (sin trim para bypass)
Delay rmsDelay(500);                // Buffer para RMS sliding window (500 samples ~10ms @ 48kHz)

// ====================================
// CONSTANTES GLOBALES
// ====================================
ditherAmount = 1.5258789062e-05;       // Cantidad de ruido para dither
SMOOTH_HISTORY_FACTOR = 0.999;         // Factor de suavizado para valores históricos (99.9%)
SMOOTH_PARAM_FACTOR = 0.001;           // Factor de suavizado para nuevos parámetros (0.1%)
LOOKAHEAD_SMOOTH_FACTOR = 0.99;        // Factor de suavizado para lookahead
expConstant = -0.99967234081321;       // Constante para cálculo exponencial de tiempos

// ====================================
// SUAVIZADO DE PARÁMETROS
// ====================================
// Suavizado del trim
smoothedTrim = trimHistory * 0.999 + j_TRIM * 0.001;
trimHistory = fixdenorm(smoothedTrim);
trimLinear = dbtoa(smoothedTrim);

// Suavizado del threshold con factor 0.999
smoothedGain = smoothedGain * 0.999 + (-a_GAIN) * 0.001;
smoothedGain = fixdenorm(smoothedGain);

// Conversión de threshold a factor lineal
thresholdLinear = 1 / pow(10, smoothedGain / 20);

// Suavizado del ceiling
smoothedCeiling = smoothedCeiling * 0.999 + b_CELLING * 0.001;
smoothedCeiling = fixdenorm(smoothedCeiling);

// Suavizado del bypass
smoothedBypass = smoothedBypass * 0.999 + h_BYPASS * 0.001;
smoothedBypass = fixdenorm(smoothedBypass);
wetAmount = 1 - smoothedBypass;  // Cantidad de señal procesada

// Suavizado del makeup gain
smoothedMakeup = smoothedMakeup * 0.999 + i_MAKEUP * 0.001;
smoothedMakeup = fixdenorm(smoothedMakeup);
makeupLinear = dbtoa(smoothedMakeup);

// Suavizado del modo delta
smoothedDelta = deltaHistory * 0.999 + k_DELTA * 0.001;
deltaHistory = fixdenorm(smoothedDelta);

// Suavizado del modo de detección
smoothedDetect = detectHistory * 0.999 + l_DETECT * 0.001;
detectHistory = fixdenorm(smoothedDetect);

// Suavizado del auto-release
smoothedAutoRelease = autoReleaseHistory * 0.999 + m_AUTOREL * 0.001;
autoReleaseHistory = fixdenorm(smoothedAutoRelease);

// ====================================
// PREPARACIÓN DE SEÑALES DE ENTRADA
// ====================================
// Aplicar trim a las entradas
leftTrimmed = in1 * trimLinear;
rightTrimmed = in2 * trimLinear;

// Conversión de ceiling a lineal
ceilingLinear = dbtoa(b_CELLING);

// Aplicar ceiling y threshold a las entradas CON TRIM
rightScaled = ceilingLinear * rightTrimmed * thresholdLinear;
leftScaled = ceilingLinear * leftTrimmed * thresholdLinear;

// ====================================
// DETECCIÓN DE NIVEL
// ====================================
// Promedio de ambos canales para detección
averageSignal = (leftScaled + rightScaled) * 0.5;
averageAbs = abs(averageSignal);

// Peak detection (instantánea)
peakDetection = averageAbs;

// RMS sliding window (ventana de ~3ms)
rmsWindowSize = max(1, floor(3 * samplerate * 0.001));  // 3ms en samples
rmsWindowInv = 1 / rmsWindowSize;

// Calcular RMS con ventana deslizante
signalSquared = averageSignal * averageSignal;
oldestSquared = rmsDelay.read(rmsWindowSize, interp="none");
rmsSumNew = (signalSquared + rmsSum) - oldestSquared;
rmsSumClipped = max(0, rmsSumNew);  // Evitar valores negativos por errores de redondeo
rmsDetection = sqrt(rmsSumClipped * rmsWindowInv);

// Actualizar delay y suma
rmsSum = rmsSumClipped;
rmsDelay.write(signalSquared);

// Interpolar entre Peak y RMS según el parámetro
detectionSignal = mix(peakDetection, rmsDetection, smoothedDetect);

// ====================================
// CÁLCULO DE CONSTANTES DE TIEMPO Y AUTO-RELEASE
// ====================================

// Auto-release: detectar transientes y ajustar release dinámicamente
finalReleaseTime = e_REL;  // Por defecto usar release manual

if(smoothedAutoRelease > 0.01) {
    // Calcular cambio en la señal
    signalChange = abs(detectionSignal - prevDetection);
    prevDetection = detectionSignal;
    
    // Detectar si es transiente (cambio rápido) o sostenido
    relativeThreshold = max(0.001, detectionSignal * 0.1);  // 10% del nivel actual
    isTransient = signalChange > relativeThreshold ? 1 : 0;
    
    // Suavizar detección de transientes
    transientSmooth = 0.99;  // Respuesta rápida
    transientDetector = (transientDetector * transientSmooth) + (isTransient * (1 - transientSmooth));
    
    // Definir rangos de release para limitador
    fastRelease = 5;     // 5ms para transientes (muy rápido)
    slowRelease = 150;   // 150ms para material sostenido
    
    // Interpolar basado en contenido detectado
    autoRelease = mix(slowRelease, fastRelease, transientDetector);
    
    // Mezclar release manual con auto
    finalReleaseTime = mix(e_REL, autoRelease, smoothedAutoRelease);
}

// Constante de tiempo para release final
releaseTime = finalReleaseTime * 0.001 * samplerate;
releaseCoeff = exp(expConstant / releaseTime);

// Seguidor de envolvente con release
envelopeFollower = max(detectionSignal, envelopeFollower * releaseCoeff);

// Constante de tiempo para attack
attackTime = d_ATK * 0.001 * samplerate;
attackCoeff = exp(expConstant / attackTime);

// Aplicar attack al seguidor de envolvente
gainReduction = gainReduction * attackCoeff + envelopeFollower * (1 - attackCoeff);
gainReduction = max(gainReduction, 0.000001);  // Evitar valores negativos o cero
gainReduction = fixdenorm(gainReduction);

// Conversión a dB para procesar con soft knee
gainReductionDb = atodb(gainReduction);

// Actualizar historiales para siguiente muestra
envelopeFollower = fixdenorm(envelopeFollower);

// ====================================
// APLICACIÓN DE SOFT KNEE LIMITER
// ====================================
// Hard knee fijo (knee = 0) para evitar discontinuidades
limitedDb = softkneeLimiter(gainReductionDb, smoothedCeiling, 0);

// ====================================
// PREPARACIÓN DE LÍMITES Y DELAYS
// ====================================
ceilingNegative = ceilingLinear * -1;  // Límite negativo
ceilingPositive = ceilingLinear * 1;   // Límite positivo

// Suavizado del lookahead (más rápido pero aún suave para evitar clicks)
smoothedLookahead = lookaheadHistory * 0.99 + n_LOOKAHEAD * 0.01;
lookaheadHistory = fixdenorm(smoothedLookahead);

// Convertir tiempo de lookahead (ms) a muestras
lookaheadSamples = int(smoothedLookahead * 0.001 * samplerate);

// Leer señales retrasadas
delayedLeft = delayLeft.read(lookaheadSamples);
delayedRight = delayRight.read(lookaheadSamples);
delayedDetectLeft = delayDetectLeft.read(lookaheadSamples);
delayedDetectRight = delayDetectRight.read(lookaheadSamples);

// Leer señales originales sin trim para bypass verdadero
delayedLeftOriginal = leftInputDelay.read(lookaheadSamples);
delayedRightOriginal = rightInputDelay.read(lookaheadSamples);

// ====================================
// GANANCIA DE COMPENSACIÓN (UNITY/MAKEUP)
// ====================================
// Nota: Esta línea ya no se usa, makeupLinear se calcula arriba
// makeupGainLinear = dbtoa(smoothedThreshold);

// ====================================
// GENERACIÓN DE DITHER
// ====================================
// TPDF (Triangular Probability Density Function) dither
// Suma de dos ruidos blancos para distribución triangular
noise1 = noise() * ditherAmount * 0.5;
noise2 = noise() * ditherAmount * 0.5;
ditherTPDF = noise1 + noise2;
ditherGated = gate(g_DITHER, ditherTPDF);

// ====================================
// CÁLCULO DE REDUCCIÓN DE GANANCIA
// ====================================
// Diferencia entre señal limitada y original (en dB)
gainReductionAmount = limitedDb - gainReductionDb;
gainReductionAmount = max(gainReductionAmount, -144);  // Limitar a -144dB mínimo
gainReductionLinear = dbtoa(gainReductionAmount);

// Calcular ganancia total aplicada para normalización del delta
totalGainApplied = trimLinear * thresholdLinear;

// ====================================
// PROCESAMIENTO CANAL IZQUIERDO
// ====================================
// Aplicar reducción de ganancia
leftProcessed = delayedDetectLeft * gainReductionLinear;

// Aplicar clipping (SIN dither aquí)
leftClipped = clamp(leftProcessed, ceilingNegative, ceilingPositive);

// Aplicar makeup gain SOLO cuando NO está en modo delta
leftWithMakeup = leftClipped * makeupLinear;
leftFinalProcessed = mix(leftClipped, leftWithMakeup, 1 - smoothedDelta);

// Modo delta - calcular diferencia normalizada por ceiling y ganancia total
// Normalizar por ceiling y por la ganancia total aplicada (trim * threshold)
leftDelta = (delayedDetectLeft - leftClipped) / (ceilingLinear * max(totalGainApplied, 1));
leftWithDelta = mix(leftFinalProcessed, leftDelta, smoothedDelta);

// Mezclar con señal original según bypass
leftFinal = mix(delayedLeftOriginal, leftWithDelta, wetAmount);

// Aplicar dither como último paso
out1 = leftFinal + ditherGated;

// ====================================
// PROCESAMIENTO CANAL DERECHO
// ====================================
// Aplicar reducción de ganancia
rightProcessed = delayedDetectRight * gainReductionLinear;

// Aplicar clipping (SIN dither aquí)
rightClipped = clamp(rightProcessed, ceilingNegative, ceilingPositive);

// Aplicar makeup gain SOLO cuando NO está en modo delta
rightWithMakeup = rightClipped * makeupLinear;
rightFinalProcessed = mix(rightClipped, rightWithMakeup, 1 - smoothedDelta);

// Modo delta - calcular diferencia normalizada por ceiling y ganancia total
// Normalizar por ceiling y por la ganancia total aplicada (trim * threshold)
rightDelta = (delayedDetectRight - rightClipped) / (ceilingLinear * max(totalGainApplied, 1));
rightWithDelta = mix(rightFinalProcessed, rightDelta, smoothedDelta);

// Mezclar con señal original según bypass
rightFinal = mix(delayedRightOriginal, rightWithDelta, wetAmount);

// Aplicar dither como último paso
out2 = rightFinal + ditherGated;

// ====================================
// ESCRIBIR EN BUFFERS DE DELAY
// ====================================
delayDetectRight.write(rightScaled);
delayDetectLeft.write(leftScaled);
delayRight.write(rightTrimmed);     // Escribir señal con trim
delayLeft.write(leftTrimmed);       // Escribir señal con trim
rightInputDelay.write(in2);         // Escribir señal SIN trim para bypass
leftInputDelay.write(in1);          // Escribir señal SIN trim para bypass

// ====================================
// GAIN REDUCTION OUTPUT - Medidor de reducción para UI
// ====================================
// gainReductionLinear ya contiene el factor de ganancia lineal
// 1 = sin reducción, 0.5 = -6dB, 0.25 = -12dB, etc.
// Este es exactamente el formato que necesitas para el medidor
gainReductionMeter = mix(1, gainReductionLinear, wetAmount);  // 1 cuando bypass, valor real cuando activo
gainReductionOutput = clamp(gainReductionMeter, 0, 1);

// ====================================
// SALIDAS
// ====================================
// out1, out2 ya definidas arriba (audio procesado L/R)
out3 = gainReductionOutput;        // Gain reduction para medidor (0-1) LINEAL
out4 = leftTrimmed;               // Señal post-trim L (para medidores de entrada)
out5 = rightTrimmed;              // Señal post-trim R (para medidores de entrada)