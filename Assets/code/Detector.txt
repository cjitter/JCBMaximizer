// =============================================================================
// DETECTOR BLOCK - Maximizer
// =============================================================================
// Sistema de detección con Peak/RMS y auto-release
//
// ENTRADAS:
// - in1: Señal L con trim (sin delay)
// - in2: Señal R con trim (sin delay)
//
// SALIDAS:
// - out1: Envolvente en dB para cálculo de ganancia
// - out2: Señal escalada L (para modo delta)
// - out3: Señal escalada R (para modo delta)
// - out4: Ceiling suavizado en dB
// - out5: Trim linear (para normalización delta)
// - out6: Threshold linear (para normalización delta)
// =============================================================================

// PARÁMETROS
Param b_CELLING(0, min=-60, default=-0.3, max=0);  // Techo máximo en dB
Param a_GAIN(0, min=0, default=0, max=24);         // Input gain (dB) - moderno
Param d_ATK(0, min=0.01, default=100, max=750);    // Tiempo de ataque en ms
Param e_REL(0, min=1, default=200, max=1000);      // Tiempo de release en ms
Param l_DETECT(0, min=0, default=0, max=1);        // Detection mode (0=Peak, 1=RMS)
Param m_AUTOREL(0, min=0, default=0, max=1);       // Auto-release enable (0-1)
Param j_TRIM(-12, min=-12, default=0, max=12);     // Input trim (para calcular normalización)

// HISTORIAS
History smoothedGain(0);         // Suavizado del gain
History smoothedCeiling(0);      // Suavizado del techo
History envelopeFollower(0);     // Seguidor de envolvente
History gainReduction(0);        // Reducción de ganancia actual
History detectHistory(0);        // Para suavizado del modo de detección
History autoReleaseHistory(0);   // Para suavizado del auto-release
History transientDetector(0);    // Detector de transientes para auto-release
History prevDetection(0);        // Detección anterior para calcular cambios
History rmsSum(0);               // Suma para RMS sliding window

// DELAYS
Delay rmsDelay(500);             // Buffer para RMS sliding window

// CONSTANTES
SMOOTH_HISTORY_FACTOR = 0.999;
SMOOTH_PARAM_FACTOR = 0.001;
expConstant = -0.99967234081321;

// PROCESAMIENTO
// Suavizado del gain (conversión a threshold negativo)
smoothedGain = smoothedGain * SMOOTH_HISTORY_FACTOR + (-a_GAIN) * SMOOTH_PARAM_FACTOR;
smoothedGain = fixdenorm(smoothedGain);

smoothedCeiling = smoothedCeiling * SMOOTH_HISTORY_FACTOR + b_CELLING * SMOOTH_PARAM_FACTOR;
smoothedCeiling = fixdenorm(smoothedCeiling);

// Suavizado de otros parámetros
smoothedDetect = detectHistory * SMOOTH_HISTORY_FACTOR + l_DETECT * SMOOTH_PARAM_FACTOR;
detectHistory = fixdenorm(smoothedDetect);

smoothedAutoRelease = autoReleaseHistory * SMOOTH_HISTORY_FACTOR + m_AUTOREL * SMOOTH_PARAM_FACTOR;
autoReleaseHistory = fixdenorm(smoothedAutoRelease);

// Conversión a lineal
ceilingLinear = dbtoa(b_CELLING);
thresholdLinear = 1 / pow(10, smoothedGain / 20);
trimLinear = dbtoa(j_TRIM);

// Aplicar ceiling y threshold a las entradas
rightScaled = ceilingLinear * in2 * thresholdLinear;
leftScaled = ceilingLinear * in1 * thresholdLinear;

// Promedio de ambos canales para detección
averageSignal = (leftScaled + rightScaled) * 0.5;
averageAbs = abs(averageSignal);

// Peak detection
peakDetection = averageAbs;

// RMS sliding window (3ms)
rmsWindowSize = max(1, floor(3 * samplerate * 0.001));
rmsWindowInv = 1 / rmsWindowSize;

signalSquared = averageSignal * averageSignal;
oldestSquared = rmsDelay.read(rmsWindowSize, interp="none");
rmsSumNew = (signalSquared + rmsSum) - oldestSquared;
rmsSumClipped = max(0, rmsSumNew);
rmsDetection = sqrt(rmsSumClipped * rmsWindowInv);

rmsSum = rmsSumClipped;
rmsDelay.write(signalSquared);

// Interpolar entre Peak y RMS
detectionSignal = mix(peakDetection, rmsDetection, smoothedDetect);

// Auto-release
finalReleaseTime = e_REL;

if(smoothedAutoRelease > 0.01) {
    signalChange = abs(detectionSignal - prevDetection);
    prevDetection = detectionSignal;
    
    relativeThreshold = max(0.001, detectionSignal * 0.1);
    isTransient = signalChange > relativeThreshold ? 1 : 0;
    
    transientSmooth = 0.99;
    transientDetector = (transientDetector * transientSmooth) + (isTransient * (1 - transientSmooth));
    
    fastRelease = 5;
    slowRelease = 150;
    
    autoRelease = mix(slowRelease, fastRelease, transientDetector);
    finalReleaseTime = mix(e_REL, autoRelease, smoothedAutoRelease);
}

// Constantes de tiempo
releaseTime = finalReleaseTime * 0.001 * samplerate;
releaseCoeff = exp(expConstant / releaseTime);

attackTime = d_ATK * 0.001 * samplerate;
attackCoeff = exp(expConstant / attackTime);

// Envelope following
envelopeFollower = max(detectionSignal, envelopeFollower * releaseCoeff);

// Attack stage
gainReduction = gainReduction * attackCoeff + envelopeFollower * (1 - attackCoeff);
gainReduction = max(gainReduction, 0.000001);
gainReduction = fixdenorm(gainReduction);

// Conversión a dB
gainReductionDb = atodb(gainReduction);

// Actualizar historiales
envelopeFollower = fixdenorm(envelopeFollower);

// SALIDAS
out1 = gainReductionDb;     // Envolvente en dB
out2 = leftScaled;          // Señal L escalada para delta
out3 = rightScaled;         // Señal R escalada para delta
out4 = smoothedCeiling;     // Ceiling suavizado para GainCalc
out5 = trimLinear;          // Trim linear para normalización
out6 = thresholdLinear;     // Threshold linear para normalización